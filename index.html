<!doctype html>

<!--

GREAT PLUMBER 65 - JS13kGames 2024
inspired by the intro of Super Mario 64 (//www.youtube.com/clip/UgkxzZJ4oTvJFhEzQ4Z3Pc-4iT2owIfoEPGO)
And by my 1Kb Peach Castle from JS1K 2019 (//js1k.com/2019-x/demo/4066)
And by the fact that Strika-nintendoka-phobia sounds like the theme Triskaidekaphobia.

-->

<title>Great plumber 65</title>
<link rel=icon href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üßë‚Äçüîß</text></svg>">
<head>
<style>
@font-face { /* title */
  font-family: m;
  src: url(m.woff2)
}

@font-face { /* letter */
  font-family: l;
  src: url(l.woff2)
}

@font-face{ /* emoji */
  font-family: emoji;
  src:url(Twemoji.ttf)
}

* {
  -webkit-tap-highlight-color: transparent;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
  -webkit-user-select: none; /* Safari */
  -ms-user-select: none; /* IE 10 and IE 11 */
  user-select: none; /* Standard syntax */
}

#b { /* body */
  margin: 0;
  background: #000;
  color: #fff;
  font: 3vmin l;
  cursor: pointer;
  text-align: center;
  overflow: hidden;
  position: absolute;
  width: 100%;
  height: 100%
}

#load { /* loading */
  margin: 45vh 0 0;
  text-align: center;
}

/* Title */
.r { color: #f23 }
.g { color: #2E2 }
.b { color: #57D }
.y { color: #ff3 }

.title {
  transform: scale(.001);
  transition: all .2s;
  margin: 40vh auto 0;
  letter-spacing: -.7vmin;
}

.title span {
  font-family: m, arial;
  -webkit-text-stroke: .5px #732;
  text-shadow: 0 .2vmin #952,0 .4vmin #842,0 .6vmin #731,0 .8vmin #621,0 1vmin #510
}

.title sup {
  -webkit-text-stroke: .5px #cc0;
  letter-spacing: -1.5vmin;
}

.title div {
  transform: scale(1.15,1.2)
}

/* Letter */
#letter {
  width: 40vmin;
  height: 55vmin;
  font: 5vmin l;
  background:#fed;
  color:#000;
  padding: 5vmin;
  text-align:left;
  margin: 15vmin 0 0 -45vmin;
  position: absolute;
  top: 0;
  left: 50%;
}

#letter div {
  color: pink;
  font-size: 12vmin;
  text-align:right;
  margin: 6vmin 0 0;
  transform: rotate(-25deg);
  transition: opacity 1s;
}

#pri {
  font: 70vmin emoji;
  position: absolute;
  left: 50%;
  margin: 15vmin 0 0 -15vmin;
  height: 40vmin;
  overflow: hidden;
  padding: 20vmin 0 0;
  transform: rotateX(20deg);
  transition: opacity 1s;
}

#pri div.a {
  transform: rotate(15deg);
}

#pri div.b {
  font: 23vmin emoji;
  position: relative;
  top: -88vmin;
  left: 3vmin;
}

[hidden]{display: none}

#content {
  background: #000;
  position: absolute;
  width:100%;
  height: 100%;
  transition: background .5s;
}

#toad {
  font: 30vmin emoji;
  margin: 40vmin 0 0 -50vmin;
  position: absolute;
  top: 0;
  left: 50%;
}

#letter.large {
  width: 55vmin;
  height: auto;
  left: 75%;
}

#eyes {
  font: 9vmin emoji;
  margin: 55vmin 0 0 -39vmin;
  position: absolute;
  top: 0;
  left: 50%;
}

#mouth {
  font: 9vmin emoji;
  margin: 63vmin 0 0 -39vmin;
  position: absolute;
  top: 0;
  left: 50%;
}

.dpad {
    position: fixed;
    width: 100%;
    bottom: 45px;
    left: 10px;
    z-index: 2;
    color: #000;
    text-align: left;
    transition: opacity .5s;
}

.dpad div {
    display: inline-block;
    font-size: 35px;
    pointer-events: all;
    margin: 10px;
    text-align: center;
    width: 50px;
    height: 50px;
    border-radius: 5px;
    background: linear-gradient(45deg, #ddd, #888);
    box-shadow: 2px 2px 5px #000;
    font-weight: 700;
    padding: 4px 0 0;
    vertical-align: bottom;
}
#bjump {
    position: absolute;
    right: 20px;
    bottom: 0;
    display: block;
    font-family: emoji;
}
.uu { opacity: 0;  }


</style>
</head>

<body id=b>
  <div id="content">
    <h2 id=load>loading...<span style='font:1px emoji;opacity:0'>üå≥</span><span style='font:1px m;opacity:0'>G</h2>
  </div>
  <div id="canvas">
    <canvas id=c></canvas>
  </div>
  <div id="textures" hidden>
    <canvas id=px></canvas>
    <img id=grass>
    <img id=sand>
    <img id=brick>
    <img id=brick2>
    <img id=roof>
    <img id=water>
    <img id=treec>
    <img id=door1>
    <img id=door2>
    <img id=flag>
    <img id=princess>
    <img id=pie>
    <img id=fenc>
    <img id=sky>
    <img id=wood>
    <img id=gr>
  </div>
  <div class="dpad uu" id="dpad">
    <div class="uu">‚Üë</div>
    <div ontouchstart="keys.u=1" ontouchend="keys.u=0">‚ñ≤</div>
    <br>
    <div ontouchstart="keys.l=1" ontouchend="keys.l=0">‚óÄÔ∏é</div>
    <div ontouchstart="keys.d=1" ontouchend="keys.d=0">‚ñº</div>
    <div ontouchstart="keys.r=1" ontouchend="keys.r=0">‚ñ∂Ô∏é</div>
    <div id="bjump" ontouchstart="keys.s=1" ontouchend="keys.s=0;jumpdone=0">üèÉ</div>
  </div>
</body>

<script>
// Known male/memale speech synth voices (thanks to people on Slack for giving me their)
female = /Female|Google US English|Susan|Hazel|Zira|Shelley|Grandma|Sandy|Martha|Aria|Priya|Heather|Hayley|Samantha|Catherine|Karen|Tessa|Moira|Kathy|Rishi|Libby/;
male = /Male|George|Rocko|Daniel|Grandpa|Eddy|Reed|Fred|Ralph|Mark|David|Arthur|Guy|Aaron|Albert|Jester/;

// Prevent long touch effect on mobile
oncontextmenu = e => { e.preventDefault(); }

// WebGL framework (//xem.github.io/W)
// (Tweaked to add a slope shape, handle animation chaining and improve perfs by sorting transparent objects only, every 60 frames)
transparent = [];
var code,xxx,yy,zz, swim, end=0;
W = {
  
  // List of 3D models that can be rendered by the framework
  // (See the end of the file for built-in models: plane, billboard, cube, pyramid...)
  models: {},
  
  // List of custom renderers
  //renderers: {},

  // Reset the framework
  // param: a <canvas> element
  reset: canvas => {

    var t;
    
    // Globals
    W.canvas = canvas;    // canvas element
    W.objs = 0;           // Object counter
    W.current = {};       // Objects current states
    W.next = {};          // Objects next states
    W.textures = {};      // Textures list

    // WebGL context
    W.gl = canvas.getContext('webgl2');
    
    // Default blending method for transparent objects
    W.gl.blendFunc(770 /* SRC_ALPHA */, 771 /* ONE_MINUS_SRC_ALPHA */);
    
    // Enable texture 0
    W.gl.activeTexture(33984 /* TEXTURE0 */);

    // Create a WebGL program
    W.program = W.gl.createProgram();
    
    // Hide polygons back-faces (optional)
    W.gl.enable(2884 /* CULL_FACE */);
    
    // Create a Vertex shader
    // (this GLSL program is called for every vertex of the scene)
    W.gl.shaderSource(
      
      t = W.gl.createShader(35633 /* VERTEX_SHADER */),
      
      `#version 300 es
      precision highp float;                        // Set default float precision
      in vec4 pos, col, uv, normal;                 // Vertex attributes: position, color, texture coordinates, normal (if any)
      uniform mat4 pv, eye, m, im;                  // Uniform transformation matrices: projection * view, eye, model, inverse model
      uniform vec4 bb;                              // If the current shape is a billboard: bb = [w, h, 1.0, 0.0]
      out vec4 v_pos, v_col, v_uv, v_normal;        // Varyings sent to the fragment shader: position, color, texture coordinates, normal (if any)
      void main() {                                 
        gl_Position = pv * (                        // Set vertex position: p * v * v_pos
          v_pos = bb.z > 0.                         // Set v_pos varying:
          ? m[3] + eye * (pos * bb)                 // Billboards always face the camera:  p * v * distance + eye * (position * [w, h, 1.0, 0.0])
          : m * pos                                 // Other objects rotate normally:      p * v * m * position
        );                                          
        v_col = col;                                // Set varyings 
        v_uv = uv;
        v_normal = transpose(inverse(m)) * normal;  // recompute normals to match model thansformation
      }`
    );
    
    // Compile the Vertex shader and attach it to the program
    W.gl.compileShader(t);
    W.gl.attachShader(W.program, t);
    //if(debug) console.log('vertex shader:', W.gl.getShaderInfoLog(t) || 'OK');
    
    // Create a Fragment shader
    // (This GLSL program is called for every fragment (pixel) of the scene)
    W.gl.shaderSource(

      t = W.gl.createShader(35632 /* FRAGMENT_SHADER */),
      
      `#version 300 es
      precision highp float;                  // Set default float precision
      in vec4 v_pos, v_col, v_uv, v_normal;   // Varyings received from the vertex shader: position, color, texture coordinates, normal (if any)
      uniform vec3 light;                     // Uniform: light direction, smooth normals enabled
      uniform vec4 o, bb;                     // options [smooth, shading enabled, ambient, mix]
      uniform sampler2D sampler;              // Uniform: 2D texture
      out vec4 c;                             // Output: final fragment color

      // The code below displays colored / textured / shaded fragments
      void main() {
        c = mix(texture(sampler, v_uv.xy), v_col, o[3]);  // base color (mix of texture and rgba)
        if(o[1] == 1.){                   // if lighting/shading is enabled:
          c = vec4(                                       // output = vec4(base color RGB * (directional shading + ambient light)), base color Alpha
            c.rgb * (max(0., dot(normalize(light - v_pos.xyz), -normalize(       // Directional shading: compute dot product of light direction and normal (0 if negative)
              o[0] > 0.                                   // if smooth shading is enabled:
              ? vec3(v_normal.xyz)                        // use smooth normals passed as varying
              : cross(dFdx(v_pos.xyz), dFdy(v_pos.xyz))   // else, compute flat normal by making a cross-product with the current fragment and its x/y neighbours
            )))
            + o[2]),                                      // add ambient light passed as uniform
            c.a                                           // use base color's alpha
          );
        }
        //else {
          c = c * vec4(1.1, 1.1, 1.1, 1);
        //}
      }`
    );
    
    // Compile the Fragment shader and attach it to the program
    W.gl.compileShader(t);
    W.gl.attachShader(W.program, t);
    //if(debug) console.log('fragment shader:', W.gl.getShaderInfoLog(t) || 'OK');
    
    // Compile the program
    W.gl.linkProgram(W.program);
    W.gl.useProgram(W.program);
    //if(debug) console.log('program:', W.gl.getProgramInfoLog(W.program) || 'OK');
    
    // Set the scene's background color (RGBA)
    W.gl.clearColor(1, 1, 1, 1);
    
    // Shortcut to set the clear color
    W.clearColor = c => W.gl.clearColor(...W.col(c));
    W.clearColor("fff");
    
    // Enable fragments depth sorting
    // (the fragments of close objects will automatically overlap the fragments of further objects)
    W.gl.enable(2929 /* DEPTH_TEST */);
    
    // When everything is loaded: set default light / camera
    W.light({y: -1});
    W.camera({fov: 30});
    
    // Draw the scene. Ignore the first frame because the default camera will probably be overwritten by the program
    setInterval(W.draw, 16);
  },

  // Set a state to an object
  setState: (state, type, texture, i, normal = [], A, B, C, Ai, Bi, Ci, AB, BC) => {

    // Custom name or default name ('o' + auto-increment)
    state.n ||= 'o' + W.objs++;
    
    // Size sets w, h and d at once (optional)
    if(state.size) state.w = state.h = state.d = state.size;
    
    // If a new texture is provided, build it and save it in W.textures
    if(state.t && state.t.width && !W.textures[state.t.id]){
      texture = W.gl.createTexture();
      W.gl.pixelStorei(37441 /* UNPACK_PREMULTIPLY_ALPHA_WEBGL */, true);
      W.gl.bindTexture(3553 /* TEXTURE_2D */, texture);
      W.gl.pixelStorei(37440 /* UNPACK_FLIP_Y_WEBGL */, 1);
      W.gl.texImage2D(3553 /* TEXTURE_2D */, 0, 6408 /* RGBA */, 6408 /* RGBA */, 5121 /* UNSIGNED_BYTE */, state.t);
      W.gl.generateMipmap(3553 /* TEXTURE_2D */);
      W.textures[state.t.id] = texture;
    }
    
    // Recompute the projection matrix if fov is set (near: 1, far: 1000, ratio: canvas ratio)
    if(state.fov){
      W.projection =     
        new DOMMatrix([
          (1 / Math.tan(state.fov * Math.PI / 180)) / (W.canvas.width / W.canvas.height), 0, 0, 0, 
          0, (1 / Math.tan(state.fov * Math.PI / 180)), 0, 0, 
          0, 0, -1.001, -1,
          0, 0, -.2, 0
        ]);
        
        
    }
    
    // Save object's type,
    // merge previous state (or default state) with the new state passed in parameter,
    // and reset f (the animation timer)
    state = {type, ...(W.current[state.n] = W.next[state.n] || {w:1, h:1, d:1, x:0, y:0, z:0, rx:0, ry:0, rz:0, b:'888', mode:4, mix: 0}), ...state, f:0};
    
    // Build the model's vertices buffer if it doesn't exist yet
    if(W.models[state.type]?.vertices && !W.models?.[state.type].verticesBuffer){
      W.gl.bindBuffer(34962 /* ARRAY_BUFFER */, W.models[state.type].verticesBuffer = W.gl.createBuffer());
      W.gl.bufferData(34962 /* ARRAY_BUFFER */, new Float32Array(W.models[state.type].vertices), 35044 /*STATIC_DRAW*/);

      // Compute smooth normals if they don't exist yet (optional)
      if(!W.models[state.type].normals && W.smooth) W.smooth(state);
      
      // Make a buffer from the smooth/custom normals (if any)
      if(W.models[state.type].normals){
        W.gl.bindBuffer(34962 /* ARRAY_BUFFER */, W.models[state.type].normalsBuffer = W.gl.createBuffer());
        W.gl.bufferData(34962 /* ARRAY_BUFFER */, new Float32Array(W.models[state.type].normals.flat()), 35044 /*STATIC_DRAW*/); 
      }      
    }
    
    // Build the model's uv buffer (if any) if it doesn't exist yet
    if(W.models[state.type]?.uv && !W.models[state.type].uvBuffer){
      W.gl.bindBuffer(34962 /* ARRAY_BUFFER */, W.models[state.type].uvBuffer = W.gl.createBuffer());
      W.gl.bufferData(34962 /* ARRAY_BUFFER */, new Float32Array(W.models[state.type].uv), 35044 /*STATIC_DRAW*/); 
    }
    
    // Build the model's index buffer (if any) and smooth normals if they don't exist yet
    if(W.models[state.type]?.indices && !W.models[state.type].indicesBuffer){
      W.gl.bindBuffer(34963 /* ELEMENT_ARRAY_BUFFER */, W.models[state.type].indicesBuffer = W.gl.createBuffer());
      W.gl.bufferData(34963 /* ELEMENT_ARRAY_BUFFER */, new Uint16Array(W.models[state.type].indices), 35044 /* STATIC_DRAW */);
    }
    
    // Set mix to 1 if no texture is set
    if(!state.t){
      state.mix = 1;
    }

    // set mix to 0 by default if a texture is set
    else if(state.t && !state.mix){
      state.mix = 0;
    }
    
    // Save new state
    W.next[state.n] = state;
    
    if(state.type === "billboard"||state.type === "plane"){transparent.push(W.next[state.n])}
  },
  
  // Draw the scene
  draw: (now, dt, v, i) => {
    //transparent = [];
    // Loop and measure time delta between frames
    dt = 16;
    W.lastFrame = now;
    //requestAnimationFrame(W.draw);
    
    if(W.next.camera.g){
      W.render(W.next[W.next.camera.g], dt, 1);
    }
    
    // Create a matrix called v containing the current camera transformation
    v = W.animation('camera');
    
    // If the camera is in a group
    if(W.next?.camera?.g){

      // premultiply the camera matrix by the group's model matrix.
      v.preMultiplySelf(W.next[W.next.camera.g].M || W.next[W.next.camera.g].m);
    }
    
    // Send it to the shaders as the Eye matrix
    W.gl.uniformMatrix4fv(
      W.gl.getUniformLocation(W.program, 'eye'),
      false,
      v.toFloat32Array()
    );
    
    // Invert it to obtain the View matrix
    v.invertSelf();

    // Premultiply it with the Perspective matrix to obtain a Projection-View matrix
    v.preMultiplySelf(W.projection);
    
    // send it to the shaders as the pv matrix
    W.gl.uniformMatrix4fv(
      W.gl.getUniformLocation(W.program, 'pv'),
      false,
      v.toFloat32Array()
    );

    // Clear canvas
    W.gl.clear(16640 /* W.gl.COLOR_BUFFER_BIT | W.gl.DEPTH_BUFFER_BIT */);
    
    // Render all the objects in the scene
    for(i in W.next){
      
      // Render the shapes with no texture and no transparency (RGB1 color)
      if(W.next[i].type != "billboard" && W.next[i].type != "plane"){
        W.render(W.next[i], dt);
      }
      
      // Add the objects with transparency (RGBA or texture) in an array
      else {
        //transparent.push(W.next[i]);
      }
    }
    //console.log(W.next, transparent);
    
    // Order transparent objects from back to front every 60 frames
    if(frame%60==0)transparent.sort((a, b) => {
      // Return a value > 0 if b is closer to the camera than a
      // Return a value < 0 if a is closer to the camera than b
      //console.log(1)
      return W.dist(b) - W.dist(a);
    });

    // Enable alpha blending
    W.gl.enable(3042 /* BLEND */);

    // Render all transparent objects
    for(i of transparent){

      // Disable depth buffer write if it's a plane or a billboard to allow transparent objects to intersect planes more easily
      if(["plane","billboard"].includes(i.type)) W.gl.depthMask(0);
    
      W.render(i, dt);
      
      W.gl.depthMask(1);
    }
    
    // Disable alpha blending for the next frame
    W.gl.disable(3042 /* BLEND */);
    
    // Transition the light's direction and send it to the shaders
    W.gl.uniform3f(
      W.gl.getUniformLocation(W.program, 'light'),
      W.lerp('light','x'), W.lerp('light','y'), W.lerp('light','z')
    );
  },
  
  // Render an object
  render: (object, dt, just_compute = ['camera','light','group'].includes(object.type), buffer) => {

    // If the object has a texture
    if(object.t) {

      // Set the texture's target (2D or cubemap)
      W.gl.bindTexture(3553 /* TEXTURE_2D */, W.textures[object.t.id]);

      // Pass texture 0 to the sampler
      W.gl.uniform1i(W.gl.getUniformLocation(W.program, 'sampler'), 0);
    }

    // If the object has an animation, increment its timer...
    if(object.f < object.a) object.f += dt;
    //if(object.a && object.n == "H") console.log(object.n, object.f)
    // ...but don't let it go over the animation duration.
    if(object.f >= object.a && object.f < object.a + 16) { 
      
      object.f = object.a + 17;
      if(object.n === "H" || object.n === "pipe")  {intro();}
    }
    //if(object.a && object.f < object.a) console.log(object.f, object.a, (new Date()));

    // Compose the model matrix from lerped transformations
    W.next[object.n].m = W.animation(object.n);

    // If the object is in a group:
    if(W.next[object.g]){

      // premultiply the model matrix by the group's model matrix.
      W.next[object.n].m.preMultiplySelf(W.next[object.g].M || W.next[object.g].m);
    }

    // send the model matrix to the vertex shader
    W.gl.uniformMatrix4fv(
      W.gl.getUniformLocation(W.program, 'm'),
      false,
      (W.next[object.n].M || W.next[object.n].m).toFloat32Array()
    );
    
    // send the inverse of the model matrix to the vertex shader
    W.gl.uniformMatrix4fv(
      W.gl.getUniformLocation(W.program, 'im'),
      false,
      (new DOMMatrix(W.next[object.n].M || W.next[object.n].m)).invertSelf().toFloat32Array()
    );
    
    // Don't render invisible items (camera, light, groups, camera's parent)
    if(!just_compute){
      
      // Set up the position buffer
      W.gl.bindBuffer(34962 /* ARRAY_BUFFER */, W.models[object.type].verticesBuffer);
      W.gl.vertexAttribPointer(buffer = W.gl.getAttribLocation(W.program, 'pos'), 3, 5126 /* FLOAT */, false, 0, 0)
      W.gl.enableVertexAttribArray(buffer);
      
      // Set up the texture coordinatess buffer (if any)
      if(W.models[object.type].uvBuffer){
        W.gl.bindBuffer(34962 /* ARRAY_BUFFER */, W.models[object.type].uvBuffer);
        W.gl.vertexAttribPointer(buffer = W.gl.getAttribLocation(W.program, 'uv'), 2, 5126 /* FLOAT */, false, 0, 0);
        W.gl.enableVertexAttribArray(buffer);
      }
      
      // Set the normals buffer
      if((object.s || W.models[object.type].customNormals) && W.models[object.type].normalsBuffer){
        W.gl.bindBuffer(34962 /* ARRAY_BUFFER */, W.models[object.type].normalsBuffer);
        W.gl.vertexAttribPointer(buffer = W.gl.getAttribLocation(W.program, 'normal'), 3, 5126 /* FLOAT */, false, 0, 0);
        W.gl.enableVertexAttribArray(buffer);
      }
      
      // Other options: [smooth, shading enabled, ambient light, texture/color mix]
      W.gl.uniform4f(

        W.gl.getUniformLocation(W.program, 'o'), 
        
        // Enable smooth shading if "s" is true
        object.s,
        
        // Enable shading if in TRIANGLE* mode and object.ns disabled
        ((object.mode > 3) || (W.gl[object.mode] > 3)) && !object.ns ? 1 : 0,
        
        // Ambient light
        W.ambientLight || 0.2,
        
        // Texture/color mix (if a texture is present. 0: fully textured, 1: fully colored)
        object.mix
      );
      
      // If the object is a billboard: send a specific uniform to the shaders:
      // [width, height, isBillboard = 1, 0]
      W.gl.uniform4f(
        W.gl.getUniformLocation(W.program, 'bb'),
        
        // Size
        object.w,
        object.h,               

        // is a billboard
        object.type === 'billboard',
        
        // Reserved
        0
      );
      
      // Set up the indices (if any)
      if(W.models[object.type].indicesBuffer){
        W.gl.bindBuffer(34963 /* ELEMENT_ARRAY_BUFFER */, W.models[object.type].indicesBuffer);
      }
        
      // Set the object's color
      W.gl.vertexAttrib4fv(
        W.gl.getAttribLocation(W.program, 'col'),
        W.col(object.b)
      );

      // Draw
      // Both indexed and unindexed models are supported.
      // You can keep the "drawElements" only if all your models are indexed.
      if(W.models[object.type].indicesBuffer){
        W.gl.drawElements(+object.mode || W.gl[object.mode], W.models[object.type].indices.length, 5123 /* UNSIGNED_SHORT */, 0);
      }
      else {
        W.gl.drawArrays(+object.mode || W.gl[object.mode], 0, W.models[object.type].vertices.length / 3);
      }
    }
  },
  
  // Helpers
  // -------
  
  // Interpolate a property between two values
  lerp: (item, property) => 
    W.next[item]?.a
    ? W.current[item][property] + (W.next[item][property] -  W.current[item][property]) * (W.next[item].f / W.next[item].a)
    : W.next[item][property],
  
  // Transition an item
  animation: (item, m = new DOMMatrix) =>
    W.next[item]
    ? m
      .translateSelf(W.lerp(item, 'x'), W.lerp(item, 'y'), W.lerp(item, 'z'))
      .rotateSelf(W.lerp(item, 'rx'),W.lerp(item, 'ry'),W.lerp(item, 'rz'))
      .scaleSelf(W.lerp(item, 'w'),W.lerp(item, 'h'),W.lerp(item, 'd'))
    : m,
    
  // Compute the distance squared between two objects (useful for sorting transparent items)
  dist: (a, b = W.next.camera) => a?.m && b?.m ? (b.m.m41 - a.m.m41)**2 + (b.m.m42 - a.m.m42)**2 + (b.m.m43 - a.m.m43)**2 : 0,
  
  // Set the ambient light level (0 to 1)
  ambient: a => W.ambientLight = a,
  
  // Convert an rgb/rgba hex string into a vec4
  col: c => [...c.replace("#","").match(c.length < 5 ? /./g : /../g).map(a => ('0x' + a) / (c.length < 5 ? 15 : 255)), 1], // rgb / rgba / rrggbb / rrggbbaa
  
  // Add a new 3D model
  add: (name, objects) => {
    W.models[name] = objects;
    if(objects.normals){
      W.models[name].customNormals = 1;
    }
    W[name] = settings => W.setState(settings, name);
  },
  
  // Built-in objects
  // ----------------
  
  group: t => W.setState(t, 'group'),
  
  move: (t, delay) => setTimeout(()=>{ W.setState(t) }, delay || 1),
  
  delete: (t, delay) => setTimeout(()=>{ delete W.next[t] }, delay || 1),
  
  camera: (t, delay) => setTimeout(()=>{ W.setState(t, t.n = 'camera') }, delay || 1),
    
  light: (t, delay) => delay ? setTimeout(()=>{ W.setState(t, t.n = 'light') }, delay) : W.setState(t, t.n = 'light'),
};

// 3D models
// =========

// Each model has:
// - A vertices array [x, y, z, x, y, z...]
// - A uv array [u, v, u, v...] (optional. Allows texturing... if absent: RGBA coloring only)
// - An indices array (optional, enables drawElements rendering... if absent: drawArrays is ised)
// - A normals array [nx, ny, nz, nx, ny, nz...] (optional... if absent: hard/smooth normals are computed by the framework when they're needed)
// The buffers (vertices, uv, indices) are built automatically when they're needed
// All models are optional, you can remove the ones you don't need to save space
// Custom models can be added from the same model, an OBJ importer is available on https://xem.github.io/WebGLFramework/obj2js/

// Plane / billboard
//
//  v1------v0
//  |       |
//  |   x   |
//  |       |
//  v2------v3

W.add("plane", {
  vertices: [
    .5, .5, 0,    -.5, .5, 0,   -.5,-.5, 0,
    .5, .5, 0,    -.5,-.5, 0,    .5,-.5, 0
  ],
  
  uv: [
    1, 1,     0, 1,    0, 0,
    1, 1,     0, 0,    1, 0
  ],
});
W.add("billboard", W.models.plane);

// Cube
//
//    v6----- v5
//   /|      /|
//  v1------v0|
//  | |  x  | |
//  | |v7---|-|v4
//  |/      |/
//  v2------v3

W.add("cube", {
  vertices: [
    .5, .5, .5,  -.5, .5, .5,  -.5,-.5, .5, // front
    .5, .5, .5,  -.5,-.5, .5,   .5,-.5, .5,
    .5, .5,-.5,   .5, .5, .5,   .5,-.5, .5, // right
    .5, .5,-.5,   .5,-.5, .5,   .5,-.5,-.5,
    .5, .5,-.5,  -.5, .5,-.5,  -.5, .5, .5, // up
    .5, .5,-.5,  -.5, .5, .5,   .5, .5, .5,
   -.5, .5, .5,  -.5, .5,-.5,  -.5,-.5,-.5, // left
   -.5, .5, .5,  -.5,-.5,-.5,  -.5,-.5, .5,
   -.5, .5,-.5,   .5, .5,-.5,   .5,-.5,-.5, // back
   -.5, .5,-.5,   .5,-.5,-.5,  -.5,-.5,-.5,
    .5,-.5, .5,  -.5,-.5, .5,  -.5,-.5,-.5, // down
    .5,-.5, .5,  -.5,-.5,-.5,   .5,-.5,-.5
  ],
  uv: [
    1, 1,   0, 1,   0, 0, // front
    1, 1,   0, 0,   1, 0,            
    1, 1,   0, 1,   0, 0, // right
    1, 1,   0, 0,   1, 0, 
    1, 1,   0, 1,   0, 0, // up
    1, 1,   0, 0,   1, 0,
    1, 1,   0, 1,   0, 0, // left
    1, 1,   0, 0,   1, 0,
    1, 1,   0, 1,   0, 0, // back
    1, 1,   0, 0,   1, 0,
    1, 1,   0, 1,   0, 0, // down
    1, 1,   0, 0,   1, 0
  ]
});

// SLOPE
//
//  /\
// |\ \
// | \ \
// |  \ \
// |___\/

W.add("slope", {
  vertices: [
    .5, .5,-.5,  -.5, .5,-.5,  -.5,-.5, .5, // front
    .5, .5,-.5,  -.5,-.5, .5,   .5,-.5, .5,
    .5, .5,-.5,   .5,-.5, .5,   .5,-.5,-.5, // right
   -.5,-.5,-.5,  -.5, -.5, .5, -.5, .5,-.5, // left
   -.5, .5,-.5,   .5, .5,-.5,   .5,-.5,-.5, // back
   -.5, .5,-.5,   .5,-.5,-.5,  -.5,-.5,-.5,
    .5,-.5, .5,  -.5,-.5, .5,  -.5,-.5,-.5, // down
    .5,-.5, .5,  -.5,-.5,-.5,   .5,-.5,-.5
  ],
  uv: [
    1, 1,   0, 1,   0, 0, // front
    1, 1,   0, 0,   1, 0,            
    1, 1,   0, 0,   0, 1, // right
    0, 1,   0, 0,   1, 1, // left
    1, 1,   0, 1,   0, 0, // back
    1, 1,   0, 0,   1, 0,
    1, 1,   0, 1,   0, 0, // down
    1, 1,   0, 0,   1, 0
  ]
});

// Pyramid
//
//      ^
//     /\\
//    // \ \
//   /+-x-\-+
//  //     \/
//  +------+

W.add("pyramid", {
  vertices: [
    -.5,-.5, .5,   .5,-.5, .5,    0, .5,  0,  // Front
     .5,-.5, .5,   .5,-.5,-.5,    0, .5,  0,  // Right
     .5,-.5,-.5,  -.5,-.5,-.5,    0, .5,  0,  // Back
    -.5,-.5,-.5,  -.5,-.5, .5,    0, .5,  0,  // Left
     .5,-.5, .5,  -.5,-.5, .5,  -.5,-.5,-.5, // down
     .5,-.5, .5,  -.5,-.5,-.5,   .5,-.5,-.5
  ],
  uv: [
    0, 0,   1, 0,  .5, 1,  // Front
    0, 0,   1, 0,  .5, 1,  // Right
    0, 0,   1, 0,  .5, 1,  // Back
    0, 0,   1, 0,  .5, 1,  // Left
    1, 1,   0, 1,   0, 0,  // down
    1, 1,   0, 0,   1, 0
  ]
});

// Sphere
//
//          =   =
//       =         =
//      =           =
//     =      x      =
//      =           =
//       =         =
//          =   =

((i, ai, j, aj, p1, p2, vertices = [], indices = [], uv = [], precision = 15) => {
  for(j = 0; j <= precision; j++){
    aj = j * Math.PI / precision;
    for(i = 0; i <= precision; i++){
      ai = i * 2 * Math.PI / precision;
      vertices.push(+(Math.sin(ai) * Math.sin(aj)/2).toFixed(6), +(Math.cos(aj)/2).toFixed(6), +(Math.cos(ai) * Math.sin(aj)/2).toFixed(6));
      uv.push((Math.sin((i/precision))) * 3.5, -Math.sin(j/precision))
      if(i < precision && j < precision){
        indices.push(p1 = j * (precision + 1) + i, (p1 + 1), p2 = p1 + (precision + 1), (p1 + 1), (p2 + 1), p2);
      }
    }
  }
  W.add("sphere", {vertices, uv, indices});
})();

// Boot speech synth in advance (Some browsers need this)
s=speechSynthesis;
V=s.getVoices();
state=0; // 0: title / 1: intro

// Texture generator (//xem.github.io/pxtex)
pxtex=(c,H,S,L,v=10,w=10,h=10,x=c.getContext`2d`,i,j,m=Math.random)=>{for(c.width=w,c.height=h,i=w;i--;)for(j=h;j--;)x.fillStyle=`hsl(${H+(m()-.5)*v},${S+(m()-.5)*v}%,${L+(m()-.5)*v}%)`,x.fillRect(i,j,1,1);return c.toDataURL()}

// Handle keyboard inputs (//xem.github.io/articles/jsgamesinputs.html)
keys = [];
onkeydown=onkeyup=(e,z='s****lurd************************l**r************l*d***u**u')=>{
  keys[z[e.which-32]]=+!!e.type[5];
  if(e.type === "keyup" && z[e.which-32] === "s"){ jumpdone = 0 }
}

// Voice player (//xem.github.io/miniSpeechRecognitionAndSynthesis/miniSpeechSynthesis/lang.html)
voice=(txt,voice,delay,rate=window.orientation>-1?1.2:1.5)=>{
  s=speechSynthesis;
  foundvoice=0;
  V=s.getVoices();
  setTimeout((i,u)=>{
    // find male/female voice
    V=s.getVoices().filter(a=>a.lang.startsWith("en"));
    for(i in V){
      if(V[i].name.match(voice)){
        u=new SpeechSynthesisUtterance(txt);
        u.voice = V[i];
        u.rate = rate;
        u.pitch = 2;
        s.speak(u);
        foundvoice = 1;
        break;
      }
    }
    // or Default english voice
    if(!foundvoice){
      for(i in V){
        u=new SpeechSynthesisUtterance(txt);
        u.voice = V[i];
        u.rate = rate;
        u.pitch = 2;
        s.speak(u);
        break;
      }
    }
  },delay);
}

// Sound FX player (//xem.github.io/MiniSoundEditor/)
t=(i,n)=>(n-i)/n;
fx = f => {
  var A,b,s,m;
  A=new AudioContext()
  m=A.createBuffer(1,96e3,48e3)
  b=m.getChannelData(0)
  for(i=96e3;i--;)b[i]=f(i)
  s=A.createBufferSource()
  s.buffer=m
  s.connect(A.destination)
  s.start()
}

// Step sound
step = (f) => {
  fx((s,r,e)=>((3800,s>3800?null:(e=t(s,3800),Math.sin(.01*s*Math.sin(.001*s+Math.sin(s/200))+Math.sin(s/200))*e*e/9))*2));
}

// Splash sound
splash = (f) => {
  fx((i)=>{
    var n=20e4;
    if (i > n) return null;
    var q = t(i,n);
    return (i<6e4?(Math.sin(-i*0.03*Math.sin(0.09*i+Math.sin(i/200))+Math.sin(i/100))/q/(i>3e3?i/2e3:6)):0)/3;
  })
}
   
// Waterjump sound
waterjump = (f) => {
  fx((i)=>{
    var n=2e4-9000;
    if (i > n) return null;
    var q = t(i+10000,n);
    return (Math.sin(-i*0.03*Math.sin(0.09*i+Math.sin(i/200))+Math.sin(i/100))*q)/3;
  })
}

// swim sound
swimsound = (f) => {
  fx((i)=>{
    var n=2e4-9000;
    if (i > n) return null;
    var q = t(i+10000,n);
    return (Math.sin(-i*0.03*Math.sin(0.09*i+Math.sin(i/200))+Math.sin(i/100))*q)/30;
  });
}
  
// Music

// Play a piano note (//xem.github.io/miniPiano)
piano = (e, V=1, m,A,volume) => {
  var v, p, c, b, w, r, D, i, s, u, D;
  // V = duration
  for(
    // Temp vars for guitar synthesis
    v = [],
    p = c = 0,
    
    // Modulation
    // This function generates the i'th sample of a sinusoidal signal with a specific frequency and amplitude
    b = (e, t, a, i) => Math.sin(e / t * 6.28 * a + i),
    
    // Instrument synthesis
    w = (e, t) => Math.sin(e / 44100 * t * 6.28 + b(e, 44100, t, 0) ** 2 + .75 * b(e, 44100, t, .25) + .1 * b(e, 44100, t, .5)),
    
    // Sound samples
    D = [],
    
    // Loop on all the samples
    i = 0;
    i < 44100 * V;
    i++
  ){
  
    // Fill the samples array
    D[i] =
    
      // The first 88 samples represent the note's attack
      (i < 58 
      ? i / 88.2 * w(i, e) 
      
      // The other samples represent the rest of the note
      : (1 - (i - 88.2) / (44100 * (V - .002))) ** ((.5 * Math.log(1e4 * e / 44100)) ** 2) * w(i, e))*volume;
  }
  
  // Play the note
  m.getChannelData(0).set(D),
  s = A.createBufferSource(),
  s.buffer = m,
  s.connect(A.destination),
  s.start()
}

// Intro tracks (//xem.github.io/midi2array/)
track1 = [1,,,,,,64,,,,,67,69,67,60,,,,,,65,,,,69,71,69,63,,,,,,67,,,,72,74,72,79,,,77,,72,67,65,76,,,72,,69,65,64,63];
track2 = [1,,,,,,64,,64,,,,64,64,64,64,65,,65,,,,65,65,65,65,67,,67,,,,67,67,67,67,65,,65,,,,65,65,65,65,64,,64,/* start melody*/,,64,64,64,64,65,,65,,,65,65,65,65,65,,65,,,65,65,65,65,66,,66,,,66,66,66,66,67,,67,,,67,67,67,67,67,,67,,,67,67,67,67,65,,65,,,65,65,65,65]

// Tracks players
playout = (track,tempo) => {
  for(var i in track){
    setTimeout("piano(440*1.06**(track1[" + i + "] - 68),3,m,A,.30)", +i * +tempo);
  }
}

playout2 = (track,tempo) => {
  for(var i in track){
    setTimeout("piano(440*1.06**(track2[" + i + "] - 82),.8,m2,A2,.20)", +i * +tempo);
  }
}

// Music player
music = () => {
  A = new AudioContext,
  A2 = new AudioContext,
  m = A.createBuffer(1, 1e6, 44100);
  m2 = A2.createBuffer(1, 1e6, 44100);
  playout2(track2,240);
  setTimeout(()=>{playout(track1, 300)},9200);
}

// Game globals
frame = 0;
walkframe=0;
walking=0;
jumpdone = 0;
lastjump=99;
nthjump=0;
G = 0.11;

// Hero state
hero = {
  x: 11,
  y: 20,
  z: -1,
  
  ry: 0,
  rcamera: 0,
  
  vx: 0,
  vy: 0,
  vz: 0,
  
  grounded: 0
};

// World map 24x20 x 17 layers (//xem.github.io/3Dmapeditor/)
map = {
  w: 25,
  h: 20,
  layers: [

  // Layer 1:

  '    ((((((((((((((((((   '+
  '((((((((((((   '+
  '(((,,((($$   '+
  '(((((((($   '+
  '  $$(((((((((((((($   '+
  '   $(((((($$  '+
  '   $(((($  '+
  '   $(((($  '+
  '   $$(((($$  '+
  '   $$$$$$$$$$$$$$$		$$   '+
  '    $$$$$$$$$$$$$$		$    '+
  '    $$                 '+
  '    $$                 '+
  '    $$         $$$    '+
  '    $$$ $$$$   $Z$  '+
  '     $$$$$$$$  $$$'+
  '     $$$$$$$$  '+
  '      $$$$$$$  '+
  '       $$$$$   '+
  '               ',

  // Layer 2:

  '0000((((((((((((((((((   '+
  '###(((###((((((###(((##1'+
  '#####(###(##(###(###1'+
  '#####(###(####(###(####1'+
  '3#####(((((####(((((####1'+
  '3#########(####(########1'+
  '3##########(##(#########1'+
  '3##########(##(#########1'+
  '3####(##(###1'+
  '3#######################1'+
  '3#####################1'+
  '3#######################1'+
  '3##########13#######1'+
  '3############13#########1'+
  '3############13#########1'+
  '3############13##########'+
  '3############13##########'+
  '3###########13##########'+
  '3############13##########'+
  '               ##########',
   
  // Layer 3:

  '####((((((((((((((((((000'+
  '####(((###((((((###(((###'+
  '######(###(####(###(#####'+
  '######(##((####(###(#####'+
  '######(((((####(((((#####'+
  '##########(####(#########'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '222222222222222##########',
   
  // Layer 4:

  '####((((((((((((((((((###'+
  '####(((############(((###'+
  '######(####((((####(#####'+
  '######(####((((####(#####'+
  '######((((#(((((((((#####'+
  '########((((((#######'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################',

  // Layer 5:

  '####((((((((((((((((((###'+
  '####(((############(((###'+
  '######(############(#####'+
  '######(############(#####'+
  '######(((((####(((((#####'+
  '##########((((((#########'+
  '############((###########'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################',

  // Layer 6:

  '####((((((((((((((((((###'+
  '####(((############(((###'+
  '######(############(#####'+
  '######(############(#####'+
  '######(((((####(((((#####'+
  '########((((((#######'+
  '############((###########'+
  '########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################',

  // Layer 7:

  '#####(((((((((((((((#####'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#######<<<,####,<<<######'+
  '##########<<<<<<#########'+
  '############9;###########'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################',

  // Layer 8:

  '###########((((##########'+
  '#########################'+
  '#########################'+
  '#######<<<,,,,,,<<<######'+
  '##########<<<<<<#########'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################',

  // Layer 9:

  '####|######((((#####|####'+
  '###########(##(##########'+
  '###########((((##########'+
  '######|###########|######'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################',

  // Layer 10:

  '###########((((##########'+
  '###########(##(##########'+
  '###########((((##########'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################',

  // Layer 11:

  '###########((((##########'+
  '###########(##(##########'+
  '###########((((##########'+
  '########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################',

  // Layer 12:

  '###########,##,##########'+
  '###########,##,##########'+
  '###########<<<<##########'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################',

  // Layer 13:

  '############((###########'+
  '############((###########'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################',

  // Layer 14:

  '############((###########'+
  '############((###########'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################',

  // Layer 15:

  '############((###########'+
  '############((###########'+
  '#######################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################',
  
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################',
  
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################',

  '############|############'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################'+
  '#########################',

  ]
};

// Human readable map
bigmap = [];

// Collision detection (returns the height of the current block, or null if there's no solid block)
collision = (x, y, z, block, fine) => {
  var
  y1 = Math.floor(y),
  x1 = Math.floor(x),
  z1 = Math.floor(z);
  block = bigmap[y1]?.[z1 * map.w + x1];
  if(y < 0) return 0;
  if(!block){
    y1 = Math.floor(y),
    x1 = Math.floor(x),
    z1 = Math.floor(z);
    block = bigmap[y1]?.[z1 * map.w + x1];
  }
  if(!block)return null;
  if(block.type === "cube") return y1+1;
  if(block.type === "fence") return (z-z1)>.9?y1+.8:y1-1;
  if(block.type === "tree") return y1+1;
  else if(block.type === "water") return y1+0.7;
  else if(block.type === "slope"){
    if(block.angle === 0){ // 1 towards -z, 0 towards +z
      fine = z - z1;
      return y1+1-fine;
    }
    else if(block.angle === 2){ // 0 towards -z, 1 towards +z
      fine = z - z1;
      return y1+fine;
    }
    if(block.angle === 3){ // 1 towards -x, 0 towards +x
      fine = x - x1;
      return y1+1-fine;
    }
    else if(block.angle === 1){ // 0 towards -x, 1 towards +x
      fine = x - x1;
      return y1+fine;
    }
  }
  return null;
};

// Load fonts
onload=()=>{
  
  setTimeout(()=>{
    // Generate pxtex textures
    grass.src = pxtex(px,105,65,50,10,20,20);
    sand.src = pxtex(px,45,85,75,10,20,20);
    roof.src = pxtex(px,10,85,55,10,50,50);
    water.src = pxtex(px,200,90,35,5,20,20);
    brick2.src = pxtex(px,75,0,90,10,40,40);

    // emoji textures
    px.width=200;px.height=200;
    ctx=px.getContext("2d");
    ctx.font='180px emoji';
    ctx.fillText("üå≥",10,160);
    treec.src=px.toDataURL()

    px.width=200;px.height=200;
    ctx=px.getContext("2d");
    ctx.scale(-1,1);
    ctx.font='130px emoji';
    ctx.fillText("üö™",-225,180);
    door1.src=px.toDataURL()

    px.width=200;px.height=200;
    ctx=px.getContext("2d");
    ctx.font='130px emoji';
    ctx.fillText("üö™",-25,180);
    door2.src=px.toDataURL()

    px.width=100;px.height=100;
    ctx=px.getContext("2d");
    ctx.scale(.8,1);
    ctx.rotate(Math.PI / 4);
    ctx.font='100px emoji';
    ctx.fillText("ü´ì",30,30);
    pie.src=px.toDataURL()

    px.width=200;px.height=200;
    ctx=px.getContext("2d");
    ctx.font='100px emoji';
    ctx.fillText("üö©",70,190);
    flag.src=px.toDataURL()

    // grid (https://i.sstatic.net/P5toG.jpg)
    px.width=40;px.height=40;
    ctx=px.getContext("2d");
    ctx.fillStyle="#000";
    ctx.fillRect(0,0,40,40);
    ctx.beginPath();
    ctx.fillStyle="#04e";
    ctx.arc(20,20,18,0,7);
    ctx.fill();
    ctx.beginPath();
    ctx.fillStyle="#000";
    ctx.arc(20,20,12,0,7);
    ctx.fill();
    ctx.fillStyle="#355";
    for(i=0;i<40;i+=5){
      ctx.fillRect(0,i,40,2);
      ctx.fillRect(i,0,2,40);
    }
    gr.src=px.toDataURL()
    
    // Fence
    px.width=200;px.height=200;
    ctx=px.getContext("2d");
    ctx.fillStyle="#c82";
    ctx.fillRect(0,80,200,20);
    ctx.fillRect(0,130,200,20);
    var gradient = ctx.createLinearGradient(0,0,100,0);
    gradient.addColorStop(0,"#940");
    gradient.addColorStop(1,"#eb6");
    ctx.fillStyle=gradient;
    ctx.fillRect(25,40,50,180);
    var gradient = ctx.createLinearGradient(100,0,200,0);
    ctx.fillStyle=gradient;
    gradient.addColorStop(0,"#940");
    gradient.addColorStop(1,"#eb6");
    ctx.fillRect(125,40,50,180);
    fenc.src=px.toDataURL()

    // wood
    px.width=200;px.height=200;
    ctx=px.getContext("2d");
    var gradient = ctx.createLinearGradient(0,0,100,0);
    ctx.fillStyle=gradient;
    gradient.addColorStop(0,"#b80");
    gradient.addColorStop(1,"#db3");
    ctx.fillRect(0,0,100,200);
    var gradient = ctx.createLinearGradient(100,0,200,0);
    ctx.fillStyle=gradient;
    gradient.addColorStop(0,"#b80");
    gradient.addColorStop(1,"#db3");
    ctx.fillRect(100,0,100,200);
    wood.src=px.toDataURL()

    // Sky
    ctx=px.getContext("2d");
    pxtex(px,200,90,35,2,512,512);
    var gradient = ctx.createLinearGradient(0,150,0,260);
    gradient.addColorStop(0,"#08D");
    gradient.addColorStop(1,"#6CF");
    ctx.fillStyle=gradient;
    ctx.fillRect(0,0,512,250);
    ctx.font="25px emoji";
    ctx.fillText("‚òÅÔ∏è",20*2-20,180+30);
    ctx.fillText("‚òÅÔ∏è",80*2-20,210+10);
    ctx.fillText("‚òÅÔ∏è",140*2-20,170+30);
    ctx.fillText("‚òÅÔ∏è",200*2-20,190+30);
    ctx.fillText("‚òÅÔ∏è",240*2-20,200+30);
    sky.src=px.toDataURL()

    // Brick
    ctx=px.getContext("2d");
    pxtex(px,75,0,90,10,40,40);
    ctx.fillStyle="#f2f2f2";
    // horizontal
    ctx.fillRect(0,9,40,1);
    ctx.fillRect(0,19,40,1);
    ctx.fillRect(0,29,40,1);
    ctx.fillRect(0,39,40,1);
    // vertical 1, 3
    ctx.fillRect(13,0,1,9);
    ctx.fillRect(26,0,1,9);
    ctx.fillRect(39,0,1,9);
    ctx.fillRect(13,20,1,9);
    ctx.fillRect(26,20,1,9);
    ctx.fillRect(39,20,1,9);
    // 2,4
    ctx.fillRect(7,10,1,9);
    ctx.fillRect(13+7,10,1,9);
    ctx.fillRect(26+7,10,1,9);
    ctx.fillRect(7,30,1,9);
    ctx.fillRect(13+7,30,1,9);
    ctx.fillRect(26+7,30,1,9);
    brick.src=px.toDataURL()

    // Mosaic
    px.width=200;px.height=200;
    ctx=px.getContext("2d");
    ctx.ellipse(100,100,70,90,0,0,7);
    ctx.clip();
    ctx.fillStyle="#008";
    ctx.strokeStyle="#fb1";
    ctx.lineWidth=10;
    ctx.fill();
    ctx.stroke();
    ctx.font='230px emoji';
    ctx.scale(.95,1);
    ctx.fillText("üßé‚Äç‚ôÄÔ∏è",-10,230);
    ctx.font='30px emoji';
    ctx.fillText("üëë",95,45);
    ctx.font='60px emoji';
    ctx.translate(40,120);
    ctx.rotate(.8);
    ctx.fillText("üíê",0,0);
    princess.src=px.toDataURL()

    // All loaded, click to start
    load.innerHTML = "Start";

    // Click
    onclick=()=>{

      // Show title screen, build 3D scene
      if(state === 0){
        
        // Create scene
        c.width=innerWidth;
        c.height=innerHeight;
        W.reset(c);
        W.ambient(0.4);
        W.light({x:-3,y:-10,z:-5});
        
        // Parse map / create bigmap
        for(y=map.layers.length;y--;){
          bigmap[y] = [];
          for(x=map.w;x--;){
            for(z=map.h;z--;){
              bigmap[y][z*map.w+x] = {type: null }
              if(map.layers[y][z*map.w+x]){
                
                code = map.layers[y][z*map.w+x]?.codePointAt(0);
                //if(y == 0)console.log(map.layers[y][z*map.w+x], code);
                // Chars 0-31: various pieces
                //
                //     0000000: \0  reserved
                //     0000001: ?   water
                //     0000010: ?   tree
                //     0000011: ?   fence
                //     ...
                //
                // Char 35: nothing
                //
                //     0100011: #   nothing
        
                if(code === 35) continue; // air
                
                if(code === 1){ // water (no shading)
                  W.cube({w:1,h:x===0?1:.85,d:1,x:x+.5,y:y+.5,z:z+.5,t:water,ns:1});
                  bigmap[y][z*map.w+x] = {type:"water"};
                }
                
                else if(code === 2){ // tree (no shading)
                  W.billboard({size:1.5,x:x+.4,y:y+.75,z:z+.5,t:treec,ns:1});
                  bigmap[y][z*map.w+x] = {type:"tree"};
                }
                
                else if(code === 3){ // fence
                  W.plane({w:1,h:1,x:x+.5,y:y+.5,z:z+1,t:fenc});
                  W.plane({w:1,h:1,x:x+.5,y:y+.5,z:z+1,t:fenc,ry:180});
                  bigmap[y][z*map.w+x] = {type:"fence"};
                }
                
                else if(code === 4){ // princess
                  W.plane({w:2.5,h:2.5,x:x+1,y:y+.25,z:z-.59,t:princess});
                  bigmap[y][z*map.w+x] = {type:"princess"};
                }
                
                else if(code === 6){ // door1
                  W.plane({w:2,h:2,x:x,y:y+1,z:z+.1,t:door1});
                  bigmap[y][z*map.w+x] = {type:"door1"};
                }
                
                else if(code === 7){ // door2
                  W.plane({w:2,h:2,x:x+1,y:y+1,z:z+.1,t:door2});
                  bigmap[y][z*map.w+x] = {type:"door2"};
                }
                
                else if(code === 8){ // window (yes, it's a pie)
                  W.plane({w:1,h:1,x:x+1,y:y,z:z+.01+(y>5 && z<6?0.2:0)+(y>2 && z>=6?-0.6:0)+(y>10?0.2:0)+(y>14?0.2:0),t:pie});
                  bigmap[y][z*map.w+x] = {type:"window"};
                }

                else if(code === 9){ // wood
                  W.cube({w:1,h:1,x:x+.5,y:y+.5,z:z+.5,t:wood});
                  bigmap[y][z*map.w+x] = {type:"wood"};
                }
                else if(code === 90){ // grid
                  //console.log(90);
                  W.cube({w:1,h:1,x:x+.5,y:y+.5,z:z+.5,t:gr});
                  bigmap[y][z*map.w+x] = {type:"grid"};
                }
                
                // Cubes/slopes/pyramids

                // Chars 32-127: 0b0xxxyyzz
                //
                // - zz (bits 0-1): rotation
                //     0¬∞
                //     90¬∞
                //     180¬∞
                //     270¬∞
                //
                //  - yy (bits 2-3): texture (pick 4)
                //     grass
                //     sand
                //     rock
                //     roof
                //     ...
                //
                //  - xxx (bits 4-6): piece
                //     000-001 reserved (chars 0-31)
                //     010 cube
                //     011 slope
                //     100 45¬∞ wall
                //     101 slope corner flat
                //     110 slope corner angled
                //     111 pyramid + flag
                
                else if(code > 31){
                  zz = code & 0b11;
                  yy = (code >> 2) & 0b11;
                  xxx = (code >> 4) & 0b111;
                  W[["","","cube", "slope","cube","cube","cube","pyramid"][xxx]]({
                    w:xxx===7?2.5:1,
                    h:[1,1,(x>0&&x<24&&z>0&&z<19&&yy===0)?1.2:1,1,1,1,1,2][xxx],
                    d:(xxx===7?2.5:1),
                    x:x+.5+(xxx===7)*0.5,
                    y:y+.5+(xxx===7)*-1.5+((x==0&&z>3&&z<19)||(x==24 && z>0))*.1,
                    z:z+.5+(xxx===7)*.2+(y>5 && z<6?0.2:0)+(y>2 && z>=6?-0.6:0)+(y>10?0.2:0)+(y>14?0.2:0),
                    ry:zz*-90,
                    t:[grass,sand,[0,0,brick,brick2][xxx],roof][yy]
                  });
                  bigmap[y][z*map.w+x] = {type:["","","cube", "slope","cube","cube","cube","pyramid"][xxx], angle: zz};
                  if(bigmap[y][z*map.w+x].type==="pyramid"){
                    if(y < 12) W.billboard({size:2,x:x+1,y:y+.65,z:z+1,t:flag, ns:1});
                  }
                }
              }
            }
          }
        }
        
        // H : hero group (moves, jumps, collides)
        W.group({n:"H",size:1,x:hero.x,y:hero.y,z:hero.z});
        
        // R: hero rotation group 
        W.group({n:"R",g:"H",size:1});
        
        // M: hero 3D model 
        W.group({n:"M",g:"H",y:.4-10}); // group
        W.cube({g:"M",n:"pipe",w:1,h:1.5,d:1,b:"090"})
        W.cube({g:"pipe",w:1.1,h:.3,d:1.1,y:.5,b:"090"})
        W.cube({g:"M",w:.25,h:.1,d:.2,y:.70-.4,b:"c10"}); // hat
        W.cube({g:"M",w:.28,h:.01,d:.2,y:.65-.4,b:"c10"});
        W.cube({g:"M",w:.2,h:.1,d:.2,y:.60-.4,b:"ec6"}); // head
        W.cube({n:"a1",g:"M",w:.05,h:.15,d:.1,y:.45-.4,b:"c10",x:-.12,z:.1}); //arms
        W.cube({n:"a2",g:"M",w:.05,h:.15,d:.1,y:.45-.4,b:"c10",x:.12,z:.1});
        W.cube({g:"M",w:.2,h:.2,d:.2,y:.40-.4,b:"00F"}); // body
        W.cube({n:"l1",g:"M",w:.1,h:.2,d:.1,y:.30-.4,b:"00F",x:-.07,z:-.05}); // legs
        W.cube({n:"l2",g:"M",w:.1,h:.2,d:.1,y:.30-.4,b:"00F",x:.06,z:-.05});
        W.cube({n:"f1",g:"M",w:.1,h:.1,d:.2,y:.15-.4,b:"810",x:-.07,z:.02}); // feet
        W.cube({n:"f2",g:"M",w:.1,h:.1,d:.2,y:.15-.4,b:"810",x:.06,z:.02});
      
        // Camera
        W.camera({g:"H",z:2,y:1.2,rx:20,ry:-90,fov:42});
        
        // Sky sphere (no shading)
        W.sphere({size:200,t:sky,ns:1});
      
        W.clearColor("8Af");

        state = 1;

        // Show title
        content.innerHTML = "<center><h1 class=title id=h><span class=r>G<span class=b>R<span class=y>E<span class=b>A<span class=g>T</span> <sup class=r>6 5</sup><div class=b>P<span class=g>L<span class=r>U<span class=y>M<span class=b>B<span class=r>E<span class=g>R</h1>";
        setTimeout(()=>h.style.transform = "scale(2.1)",100);
        setTimeout(()=>h.style.transform = "scale(1.9)",300);
        setTimeout(()=>h.style.transform = "scale(2)",500);
        
        // Coin sound
        fx((i)=>{
          var n=1.6e4;
          var c=n/7;
          if (i > n) return null;
          var q=Math.pow(t(i,n),2.1);
          return (i<c ? ((i+Math.sin(-i/900)*10)&16) : i&13) ?q:-q;
        });

        // Speak
        voice("It's er meee... the great plumber!",male,1000);

        // Black screen
        setTimeout(()=>{
          content.innerHTML = "";
        },3500);

        // Show princess/letter
        setTimeout(()=>{

          // HTML, canvas
          content.innerHTML = "<div id=pri><div class=a>ü§±</div><div class=b>üëë</div></div><div id=letter>Dear plumber:<br>Please come to the castle.<br>I... have a &nbsp;leak.<br>Yours truly --<br>Princess Frogchair<br><div>Pitch";
          content.style.background = "transparent";

          // Voice
          voice(letter.innerText, female, 500);

          // Reset keys
          keys = {u:0, l:0, r:0, d:0, s:0};

        }, 4000);

        // Start intro and music
        setTimeout(music,14000)
        setTimeout(intro,15000)
      }
    }
  },100);
}

// Intro animation
introstep = -1;

intro = () => {

  introstep++;

  if(introstep === 0){

    // Hide princess/letter
    pri.style.opacity = letter.style.opacity = 0;

    // Move hero/camera (hero is hidden)
    hero.y = 12;
    hero.z = -.5;
    hero.x = 10;
    W.move({n:"H",x:hero.x,y:hero.y,z:hero.z,a:5000})
    W.move({n:"camera",y:1.2,rx:0,a:2500});
  }
  else if(introstep === 1){
    hero.x = 13;
    hero.y = 4;
    hero.z = 6.5;
    W.move({n:"H",x:hero.x,y:hero.y,z:hero.z,a:5000})
    W.move({n:"camera",rx:0,ry:0,a:5000/2})
  }

  else if(introstep === 2){
    hero.x = 14;
    hero.y = 4;
    hero.z = 8;
    W.move({n:"H",x:hero.x,y:hero.y,z:hero.z,a:3000})
    W.move({n:"camera",rx:0,ry:5,a:3000/2})
  }

  else if(introstep === 3){
    hero.x = 26;
    hero.y = 5;
    hero.z = 8;
    W.move({n:"H",x:hero.x,y:hero.y,z:hero.z,a:5000})
    W.move({n:"camera",rx:-25,ry:80,a:5000/2})
  }

  else if(introstep === 4){
    hero.x = 26;
    hero.y = 4;
    hero.z = 7;
    W.move({n:"H",x:hero.x,y:hero.y,z:hero.z,a:2000})
    W.move({n:"camera",rx:-25,ry:90,a:2000/2})
  }

  else if(introstep === 5){
    hero.x = 22;
    hero.y = 3;
    hero.z = 6;
    W.move({n:"H",x:hero.x,y:hero.y,z:hero.z,a:2000})
    W.move({n:"camera",rx:-15,ry:100,a:2000/2})
  }
  else if(introstep === 6){
    hero.x = 6;
    hero.y = 5;
    hero.z = 4;
    W.move({n:"H",x:hero.x,y:hero.y,z:hero.z,a:7000})
    W.move({n:"camera",rx:-10,ry:180,a:7000/2})
  }
  else if(introstep === 7){
    hero.x = 4;
    hero.y = 4;
    hero.z = 15;
    W.move({n:"H",x:hero.x,y:hero.y,z:hero.z,a:5000})
    W.move({n:"camera",rx:-15,ry:270,a:5000/2})
  }
  else if(introstep === 8){
    hero.x = 8;
    hero.y = 3;
    hero.z = 17;
    W.move({n:"H",x:hero.x,y:hero.y,z:hero.z,a:5000})
    W.move({n:"camera",rx:-15,ry:340,a:5000/2})
  }
  else if(introstep === 9){
    hero.x = 10;
    hero.y = 1.4;
    hero.z = 16;
    W.move({n:"H",x:hero.x,y:hero.y,z:hero.z,a:3000})
    W.move({n:"camera",rx:-10,ry:360,a:3000/2})
    W.group({n:"M",y:-3.4,a:1000});

    // Show mobile/Tablet controls
    if(window.orientation>-1)){
      dpad.classList.remove("uu");
    }
  }
  else if(introstep === 10){
    hero.y = 0.4;
    W.move({n:"M",y:0.4,a:2000});
    W.move({n:"pipe",y:-.2,a:2000});
  }
  else if(introstep === 11){
    W.move({n:"pipe",y:-3.4,a:2000});
    hero.y = 1.5;
    W.move({n:"H",x:hero.x,y:hero.y,z:hero.z,a:2000})
    
    // Sound
    fx((i)=>{
      var n=3e4;
      if (i > n) return null;
      var q = t(i,n);
      return Math.sin(i*0.001*Math.sin(0.009*i+Math.sin(i/200))+Math.sin(i/100))*q*q;
    });
  }
  else if(introstep === 12){
    W.move({n:"pipe",y:-100,size:.01,a:1});

    // Intro ends, start game loop
    setTimeout(()=>{

      // Game loop (//github.com/xem/mini3DPlatformer)
      setInterval(()=>{
        
        var x, y, z, col, dx, dz, nw, ne, sw, se, lastx, lastz, lasty;
        frame++; 
        lasty = hero.y;
        
        // Rotate  left / right
        if(keys.r || keys.l){
          hero.rcamera += (-keys.l + keys.r) * 2;
        }
        
        // Move hero's group
        W.move({n:"R", rz: hero.rcamera});
        W.move({n:"H", x:hero.x, y: hero.y, z:hero.z, ry: hero.ry - hero.rcamera});

        nw = (collision(hero.x-.15, hero.y, hero.z-.15)||hero.y)+.02;
        ne = (collision(hero.x+.15, hero.y, hero.z-.15)||hero.y)+.02;
        sw = (collision(hero.x-.15, hero.y, hero.z+.15)||hero.y)+.02;
        se = (collision(hero.x+.15, hero.y, hero.z+.15)||hero.y)+.02;
        
        // Grounded
        hero.grounded = 0;
        if(nw || ne || sw || se) {
            hero.y = Math.max(nw, ne, sw, se);
        }

        nw = (collision(hero.x-.15, hero.y-.2, hero.z-.15));
        ne = (collision(hero.x+.15, hero.y-.2, hero.z-.15));
        sw = (collision(hero.x-.15, hero.y-.2, hero.z+.15));
        se = (collision(hero.x+.15, hero.y-.2, hero.z+.15));
        
        if(nw > hero.y - .2 || ne > hero.y - .2 || sw > hero.y - .2 || se > hero.y - .2){
          hero.grounded = 1;
        }
        if(nw > hero.y && ne > hero.y && sw > hero.y && se > hero.y && nw < hero.y - .2 && ne < hero.y - .2 && sw < hero.y - .2 && se < hero.y - .2){
          hero.y += .1;
          hero.grounded = 1;
        }
        
        lastjump++;

        // jump
        if(hero.grounded && keys.s && !jumpdone){
          if(lastjump < 60 && nthjump === 1){
            hero.vy += 1.5;
            voice("hoohoo",male,1);
          }
          else if(lastjump < 70 && nthjump === 2){
            hero.vy = 1.8;
            voice("yahoooo",male,1);
          }
          else {
            hero.vy += swim ? 1 : 1.1;
            nthjump = 0;
            if(swim) waterjump();
            else{
              voice("woo",male,1);
            }
          }
          jumpdone = 1;
          lastjump = 0;
          nthjump++;
        }
        
        // roulade
        if(nthjump === 3 && lastjump === 18){
          W.move({n:"M",rx:-360,a:400});
        }
        
        if(nthjump === 3 && lastjump === 90){
          W.move({n:"M",rx:0,a:1});
        }
        
        // Fall
        hero.vy -= G;
        
        if(hero.vy < -G) hero.vy = -G; 
        
        hero.y += hero.vy;
        if(collision(hero.x, hero.y+.5, hero.z) > 0){
          hero.y -= hero.vy;
          hero.vy = 0;
        }
        
        if(nthjump ===3){
          if(hero.y > lasty + .2) hero.y = lasty + .2;
        }
        else {
          if(hero.y > lasty + .1) hero.y = lasty + .1;
        }
        
        if(
          hero.y < 1 && 
          (block = bigmap[Math.floor(hero.y)]?.[Math.floor(hero.z) * map.w + Math.floor(hero.x)].type != "water")
        ){
          hero.y = 1;
          W.move({n:"M",rx:0,a:1});
        }
        
        // swim
        
        if(hero.y < .85 && W.next.M.rx != -70 && (lastjump > 20||nthjump === 1)) {
          W.move({n:"M",z:.1,y:.2,rx:-70,a:200});
          nthjump = -1;
          swim = 1;
          splash();
        }
        else if(hero.y > .85 && W.next.M.rx != 0 && (lastjump > 120||nthjump === 1)) {
          W.move({n:"M",z:0,y:.4,rx:0,a:200});
          swim = 0;
        }
        
        lastx = hero.x;
        lastz = hero.z;
        
        // Go front / back
        if(keys.u || keys.d){
          
          walking = 1;
          walkframe++;
          
          if(hero.grounded){
          
            // Move arms/legs
            W.move({n:"a1",z:.1 + Math.cos(walkframe/2)*.02}); //arms
            W.move({n:"a2",z:.1 - Math.cos(walkframe/2)*.02});
            W.move({n:"l1",z:-.05 - Math.cos(walkframe/2)*.02}); // legs
            W.move({n:"l2",z:-.05 + Math.cos(walkframe/2)*.02});
            W.move({n:"f1",z:.01 - Math.cos(walkframe/2)*.02}); // feet
            W.move({n:"f2",z:.01 + Math.cos(walkframe/2)*.02});
            if(walkframe % 10===0){
              if(swim) swimsound();
              else step();
            }
          }
          
          dz = (-keys.u + keys.d) * Math.cos(-hero.rcamera*Math.PI/180) / (swim ? 40 : 20);
          dx = (-keys.u + keys.d) * Math.sin(-hero.rcamera*Math.PI/180) / (swim ? 40 : 20);
          
          hero.x += dx;
          nw = (collision(hero.x-.15, hero.y, hero.z-.15));
          ne = (collision(hero.x+.15, hero.y, hero.z-.15));
          sw = (collision(hero.x-.15, hero.y, hero.z+.15));
          se = (collision(hero.x+.15, hero.y, hero.z+.15));
          nw2 = (collision(hero.x-.15, hero.y+.5, hero.z-.15));
          ne2 = (collision(hero.x+.15, hero.y+.5, hero.z-.15));
          sw2 = (collision(hero.x-.15, hero.y+.5, hero.z+.15));
          se2 = (collision(hero.x+.15, hero.y+.5, hero.z+.15));
          
          if(
            nw > hero.y + .2 || ne > hero.y + .2 || sw > hero.y + .2 || se > hero.y + .2
            || nw2 > hero.y + .5 || ne2 > hero.y + .5 || sw2 > hero.y + .5 || se2 > hero.y + .5
          ){
            hero.x = lastx;
          }
          
          hero.z += dz;
          nw = (collision(hero.x-.15, hero.y, hero.z-.15));
          ne = (collision(hero.x+.15, hero.y, hero.z-.15));
          sw = (collision(hero.x-.15, hero.y, hero.z+.15));
          se = (collision(hero.x+.15, hero.y, hero.z+.15));
          nw2 = (collision(hero.x-.15, hero.y+.5, hero.z-.15));
          ne2 = (collision(hero.x+.15, hero.y+.5, hero.z-.15));
          sw2 = (collision(hero.x-.15, hero.y+.5, hero.z+.15));
          se2 = (collision(hero.x+.15, hero.y+.5, hero.z+.15));
          if(
            nw > hero.y + .2 || ne > hero.y + .2 || sw > hero.y + .2 || se > hero.y + .2
            || nw2 > hero.y + .5 || ne2 > hero.y + .5 || sw2 > hero.y + .5 || se2 > hero.y + .5
          ){
            hero.z = lastz;
          } 
        }
        else {
          walking = 0;
          walkframe = 0;
        }
        
        if(hero.x < 0) hero.x = 0;
        if(hero.x > 25) hero.x = 25;
        if(hero.z < 0) hero.z = 0;
        if(hero.z > 20) hero.z = 20;
        
        if(!hero.grounded && lastjump < 50){
          W.move({n:"a2",y:.2,rz:180,a:200},50);
        }
        else {
          W.move({n:"a2",y:.05,rz:0,a:0});
        }

        // Enter castle
        if(!end && hero.x >= 12 && hero.x <= 14 && hero.z < 3){
          end = 1;
          content.innerHTML = "";
          content.style.background = "#000";

          // Door sound
          fx(i=>{
            var n=3e4;
            if (i > n) return null;
            var q = t(i,n);
            return Math.sin(i*0.001*Math.sin(0.009*i+Math.sin(i/200))+Math.sin(i/100))*q*q;
          });

          setTimeout(()=>{
            content.innerHTML = "<div id=toad>üçÑ</div><div id=eyes>üëÄ</div><div id=mouth>üëÖ</div><div id=letter class=large>Hello plumber, I am a speaking mushroom NPC...<br>I'm afraid you can't go further in this demo because we reached 13kb and we have strikanintendokaphobia, the fear of being striked by Nintendo! The princess is in another entry..."
            A3 = new AudioContext,
            m3 = A3.createBuffer(1, 1e6, 44100);
            track3 = [1,,,67,,69,,67,,66,67,72,76,,,,65,,67,,65,,64,65,71,74,,,,64,,65,,64,,63,64,69,72,,,,72,74,76,74,72,69,66,,64,63,62,60,57,54,50,,,,,67,,69,,67,,66,67,72,76,,,,65,,67,,65,,64,65,71,74,,,,64,,65,,64,,63,64,69,72,,,,69,71,72,74,72,74,69,,71,69,71,72,,72,,,72,72,72,,55,54,55,52,55,60,64,,60,59,60,59,57,57,57,,57,56,57,53,57,64,65,,64,62,65,60,59,59,59,,59,58,59,55,59,64,67,,65,64,67,65,64,64,64,,62,60,64,62,60,62,57,,62,60,64,62,60,62,57,,62,60,64,62,60,62,55,,55,60,67,67,65,65,64,64,62,57,59,52,55,60,64,,60,59,60,59,57,57,57,,57,56,57,53,57,64,65,,64,62,65,60,59,59,59,,59,58,59,55,59,64,67,,65,64,67,65,64,64,64,,62,60,64,62,60,62,57,,62,60,64,62,60,62,57,,59,57,59,60,,60,,,60,60,60];
            playout3 = (track,tempo) => {
              for(var i in track){
                setTimeout("piano(440*1.06**(track3[" + i + "] - 82),2,m3,A3,.20)", +i * +tempo);
              }
            }
            voice(letter.innerText,female,100,window.orientation>-1?.5:3)
            setTimeout(()=>{playout3(track3,300)},10500);
          },1000);
        }
      },16);
  },10);
  }
}
</script>